/**
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the Commercial License found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = _interopRequireWildcard(require("react"));

var _context = _interopRequireDefault(require("@inovua/reactdatagrid-community/context"));

var _join = _interopRequireDefault(require("@inovua/reactdatagrid-community/packages/join"));

var _LockedRowCell = _interopRequireDefault(require("./LockedRowCell"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var defaultClassName = 'InovuaReactDataGrid__locked-row';

var renderCellsMaybeLocked = function renderCellsMaybeLocked(cells, row, computedProps) {
  var startCount = computedProps.lockedStartColumns.length;
  var unlockedCount = computedProps.unlockedColumns.length;
  var lockedStartColumns = computedProps.lockedStartColumns,
      lockedEndColumns = computedProps.lockedEndColumns,
      unlockedColumns = computedProps.unlockedColumns,
      totalLockedStartWidth = computedProps.totalLockedStartWidth,
      totalLockedEndWidth = computedProps.totalLockedEndWidth,
      totalUnlockedWidth = computedProps.totalUnlockedWidth,
      summary = computedProps.computedSummary;
  var lockedStartCells = cells.slice(0, startCount);
  var unlockedCells = cells.slice(startCount, startCount + unlockedCount);
  var lockedEndCells = cells.slice(startCount + unlockedCount);
  var rtl = computedProps.rtl;

  if (row.renderLockedStart) {
    lockedStartCells = row.renderLockedStart({
      columns: lockedStartColumns,
      value: lockedStartCells,
      summary: summary
    }, computedProps);
  }

  if (row.renderLockedEnd) {
    lockedEndCells = row.renderLockedEnd({
      columns: lockedEndColumns,
      value: lockedEndCells,
      summary: summary
    }, computedProps);
  }

  if (row.renderUnlocked) {
    unlockedCells = row.renderUnlocked({
      columns: unlockedColumns,
      value: unlockedCells,
      summary: summary
    }, computedProps);
  }

  return [_react.default.createElement("div", {
    key: "locked-start",
    "data-name": "start",
    style: {
      width: totalLockedStartWidth
    },
    className: (0, _join.default)("".concat(defaultClassName, "-group ").concat(defaultClassName, "-group--locked-start ").concat(defaultClassName, "-group--").concat(rtl ? 'rtl' : 'ltr'))
  }, lockedStartCells), _react.default.createElement("div", {
    key: "locked_rows_group",
    className: "".concat(defaultClassName, "-group ").concat(defaultClassName, "-group--unlocked ").concat(defaultClassName, "-group--").concat(rtl ? 'rtl' : 'ltr'),
    style: {
      width: totalUnlockedWidth
    }
  }, unlockedCells), _react.default.createElement("div", {
    key: "locked-end",
    "data-name": "end",
    style: {
      width: totalLockedEndWidth
    },
    className: (0, _join.default)("".concat(defaultClassName, "-group ").concat(defaultClassName, "-group--locked-end  ").concat(defaultClassName, "-group--").concat(rtl ? 'rtl' : 'ltr'))
  }, lockedEndCells)];
};

var renderLockedRow = function renderLockedRow(row, rowIndex, rows, computedProps, position) {
  var id = rowIndex;
  var firstUnlockedIndex = computedProps.firstUnlockedIndex;
  var firstLockedEndIndex = computedProps.firstLockedEndIndex;
  var lastLockedStartIndex = computedProps.lastLockedStartIndex;
  var lastUnlockedIndex = computedProps.lastUnlockedIndex;
  var rtl = computedProps.rtl;
  var colspanned = {};
  var cells = computedProps.visibleColumns.map(function (col, index, array) {
    var colspan = row.colspan;
    var computedWidth = col.computedWidth;

    if (colspanned[col.id]) {
      return null;
    }

    if (colspan && (0, _typeof2.default)(colspan) === 'object' && colspan[col.id]) {
      colspan = colspan[col.id];
    }

    if (typeof colspan === 'function') {
      colspan = colspan({
        column: col,
        columnIndex: col.computedVisibleIndex,
        rowPosition: position,
        row: row,
        rowIndex: rowIndex
      }, computedProps);
    }

    var lastIndexForCurrentColumn = index;

    if (colspan && typeof colspan === 'number' && colspan > 1) {
      var remainingColumns = colspan - 1;
      var spanColIndex = index;

      while (remainingColumns) {
        var spanCol = computedProps.visibleColumns[spanColIndex + 1];

        if (!spanCol) {
          break;
        }

        if (spanCol.computedLocked !== col.computedLocked) {
          break;
        }

        computedWidth += spanCol.computedWidth;
        colspanned[spanCol.id] = true;
        spanColIndex++;
        lastIndexForCurrentColumn++;
        remainingColumns--;
      }
    }

    var last = lastIndexForCurrentColumn === array.length - 1;
    var firstInSection = index === 0 || index === firstUnlockedIndex || index === firstLockedEndIndex;
    var lastInSection = lastIndexForCurrentColumn === lastLockedStartIndex || lastIndexForCurrentColumn === lastUnlockedIndex || last;
    var showBorderRight = lastIndexForCurrentColumn === lastLockedStartIndex;
    var showBorderLeft = computedProps.showVerticalCellBorders ? index !== 0 && index !== firstUnlockedIndex : index === firstLockedEndIndex;
    return _react.default.createElement(_LockedRowCell.default, {
      key: col.id,
      row: row,
      last: last,
      rtl: rtl,
      first: index === 0,
      firstInSection: firstInSection,
      lastInSection: lastInSection,
      showBorderBottom: showBorderBottom,
      showBorderRight: rtl ? showBorderLeft : showBorderRight,
      showBorderLeft: rtl ? showBorderRight : showBorderLeft,
      rowIndex: rowIndex,
      columnIndex: index,
      rowPosition: position,
      column: col,
      computedWidth: computedWidth,
      computedProps: computedProps
    });
  });
  cells = renderCellsMaybeLocked(cells, row, computedProps);
  var firstInSection = rowIndex === 0;
  var lastInSection = rowIndex === rows.length - 1;
  var lockedRowStyle = {
    minWidth: computedProps.minRowWidth
  };

  if (computedProps.lockedRowStyle) {
    if (typeof computedProps.lockedRowStyle === 'function') {
      var result = computedProps.lockedRowStyle({
        style: lockedRowStyle,
        row: row,
        rowIndex: rowIndex,
        firstInSection: firstInSection,
        lastInSection: lastInSection
      }, computedProps);

      if (result !== undefined) {
        lockedRowStyle = _objectSpread(_objectSpread({}, lockedRowStyle), result);
      }
    } else {
      lockedRowStyle = _objectSpread(_objectSpread({}, lockedRowStyle), computedProps.lockedRowStyle);
    }
  }

  var cls = '';

  if (computedProps.lockedRowClassName) {
    if (typeof computedProps.lockedRowClassName === 'function') {
      cls = computedProps.lockedRowClassName({
        style: lockedRowStyle,
        row: row,
        rowIndex: rowIndex,
        firstInSection: firstInSection,
        lastInSection: lastInSection
      }, computedProps) || '';
    } else {
      cls = computedProps.lockedRowClassName || '';
    }
  }

  var showBorderBottom = computedProps.showHorizontalCellBorders && !lastInSection;
  return _react.default.createElement("div", {
    key: id,
    style: lockedRowStyle,
    className: (0, _join.default)(cls, defaultClassName, "".concat(defaultClassName, "--position-").concat(row.position), firstInSection && "".concat(defaultClassName, "--first-in-section"), showBorderBottom && "".concat(defaultClassName, "--show-border-bottom"), lastInSection && "".concat(defaultClassName, "--last-in-section"))
  }, cells);
};

var _default = function _default(_ref) {
  var rows = _ref.rows,
      position = _ref.position,
      style = _ref.style,
      children = _ref.children;
  var computedProps = (0, _react.useContext)(_context.default);
  return _react.default.createElement("div", {
    style: _objectSpread(_objectSpread({}, style), {}, {
      overflow: 'hidden',
      maxWidth: computedProps.viewportAvailableWidth
    }),
    className: (0, _join.default)("InovuaReactDataGrid__locked-rows-container InovuaReactDataGrid__locked-rows-container--position-".concat(position), computedProps.nativeScroll && computedProps.scrollbars.vertical && "InovuaReactDataGrid__locked-rows-container--show-border-right")
  }, _react.default.createElement("div", {
    className: "InovuaReactDataGrid__locked-rows-container-scroller"
  }, rows.map(function (row, i) {
    return renderLockedRow(row, i, rows, computedProps, position);
  })), children);
};

exports.default = _default;