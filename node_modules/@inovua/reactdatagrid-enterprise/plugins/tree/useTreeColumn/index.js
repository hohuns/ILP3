/**
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the Commercial License found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _useProperty5 = _interopRequireDefault(require("@inovua/reactdatagrid-community/hooks/useProperty"));

var _batchUpdate = _interopRequireDefault(require("@inovua/reactdatagrid-community/utils/batchUpdate"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var EXPANDABLE_NODE_INFO = {};
var EMPTY_OBJECT = {};

var isNodeExpandableAt_FromProps = function isNodeExpandableAt_FromProps(computedPropsRef, rowIndex) {
  var computedProps = computedPropsRef.current;

  if (!computedProps) {
    return false;
  }

  var data = computedProps.getItemAt(rowIndex);

  if (!data) {
    return false;
  }

  if (data.__group) {
    return false;
  }

  if (data.__nodeProps && data.__nodeProps.leafNode) {
    return false;
  }

  var id = computedProps.getItemId(data);
  var initialProps = computedProps.initialProps;

  if (initialProps.unexpandableNodes && initialProps.unexpandableNodes[id]) {
    return false;
  }

  if (!initialProps.isNodeExpandable) {
    return true;
  }

  EXPANDABLE_NODE_INFO.id = id;
  EXPANDABLE_NODE_INFO.data = data;
  EXPANDABLE_NODE_INFO.rowIndex = rowIndex;
  EXPANDABLE_NODE_INFO.node = data;
  EXPANDABLE_NODE_INFO.nodeProps = data.__nodeProps;
  return initialProps.isNodeExpandable(EXPANDABLE_NODE_INFO);
};

var loadNodeAsync_FromProps = function loadNodeAsync_FromProps(computedPropsRef, dataOrIndex, callback) {
  var computedProps = computedPropsRef.current;

  if (!computedProps) {
    return;
  }

  var data = typeof dataOrIndex === 'number' ? computedProps.getItemAt(dataOrIndex) : dataOrIndex;
  var nodeId = computedProps.getItemId(data);
  var nodeCache = computedProps.getNodeCache();
  var once = !!computedProps.initialProps.loadNodeOnce;
  var loadFn = computedProps.computedLoadNode;

  if (!loadFn && callback) {
    callback();
    return;
  }

  if (once && nodeCache && nodeCache[nodeId] != null && nodeCache[nodeId][computedProps.initialProps.nodesProperty] !== undefined) {
    if (callback) {
      callback();
    }

    return;
  }

  var loadingNodes = _objectSpread({}, computedProps.computedLoadingNodes);

  var result = loadFn({
    node: data,
    nodeProps: data.__nodeProps
  });

  if (Array.isArray(result)) {
    computedProps.appendCacheForNode(nodeId, (0, _defineProperty2.default)({}, computedProps.initialProps.nodesProperty, result));

    if (callback) {
      callback();
    }
  } else {
    loadingNodes[nodeId] = true;
    computedProps.setLoadingNodes(loadingNodes);

    if (callback) {
      callback();
    }
  }

  if (typeof result.then === 'function') {
    result.then(function (nodes) {
      var computedProps = computedPropsRef.current;

      if (!computedProps) {
        return;
      }

      var loadingNodes = _objectSpread({}, computedProps.computedLoadingNodes);

      delete loadingNodes[nodeId];
      computedProps.setLoadingNodes(loadingNodes);
      computedProps.appendCacheForNode(nodeId, (0, _defineProperty2.default)({}, computedProps.initialProps.nodesProperty, nodes));
    });
  }
};

var useTreeColumn = function useTreeColumn(props, computedProps, computedPropsRef) {
  var computedTreeEnabled = props.treeEnabled || !!props.treeColumn;

  var _useProperty = (0, _useProperty5.default)(props, 'expandedNodes', undefined, {
    onChange: function onChange(expandedNodes) {
      var fn = computedProps.initialProps.onExpandedNodesChange;

      if (fn) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        fn.apply(void 0, [{
          expandedNodes: expandedNodes
        }].concat(args));
      }
    }
  }),
      _useProperty2 = (0, _slicedToArray2.default)(_useProperty, 2),
      expandedNodes = _useProperty2[0],
      doSetExpandedNodes = _useProperty2[1];

  var isNodeExpandableAt = function isNodeExpandableAt(index) {
    return isNodeExpandableAt_FromProps(computedPropsRef, index);
  };

  var setExpandedNodes = function setExpandedNodes(expandedNodes, collapsedNodes, cfg) {
    cfg = cfg || {};
    var _cfg = cfg,
        id = _cfg.id,
        data = _cfg.data,
        expanded = _cfg.expanded;
    var index;
    var nodeProps;
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    var initialProps = computedProps.initialProps;

    if (data) {
      nodeProps = data.__nodeProps;
      index = computedProps.dataIndexMap[id];

      if (!expanded) {
        if (initialProps.onNodeCollapse && initialProps.onNodeCollapse({
          nodeProps: nodeProps,
          node: data,
          data: data,
          id: id,
          index: index
        }) === false) {
          return;
        }
      } else {
        if (!isNodeExpandableAt(index)) {
          return;
        }

        if (initialProps.onNodeExpand && initialProps.onNodeExpand({
          nodeProps: nodeProps,
          node: data,
          data: data,
          id: id,
          index: index
        }) === false) {
          return;
        }
      }

      if (initialProps.onNodeExpandChange && initialProps.onNodeExpandChange({
        expandedNodes: expandedNodes,
        id: id,
        index: index,
        data: data,
        nodeProps: nodeProps,
        node: data,
        nodeExpanded: expanded
      }) === false) {
        return;
      }
    }

    if (initialProps.onExpandedNodesChange) {
      initialProps.onExpandedNodesChange({
        expandedNodes: expandedNodes,
        nodeExpanded: expanded,
        nodeProps: nodeProps,
        data: data,
        id: id,
        index: index
      });
    }

    if (expandedNodes) {
      doSetExpandedNodes(expandedNodes);
    }
  };

  var _useProperty3 = (0, _useProperty5.default)(props, 'nodeCache'),
      _useProperty4 = (0, _slicedToArray2.default)(_useProperty3, 2),
      nodeCache = _useProperty4[0],
      doSetNodeCache = _useProperty4[1];

  var _useState = (0, _react.useState)({}),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      loadingNodes = _useState2[0],
      setLoadingNodes = _useState2[1];

  var collapsingNodesRef = (0, _react.useRef)({});

  var isNodeExpanded = function isNodeExpanded(data) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return false;
    }

    if (data == null) {
      return false;
    }

    var index;

    if (typeof data == 'number') {
      index = data;
      data = computedProps.getItemAt(index);
    }

    var expandedNodes = computedProps.computedExpandedNodes;
    var id = computedProps.getItemId(data);

    if (!expandedNodes) {
      return false;
    }

    return !!expandedNodes[id];
  };

  var getExpandedNodes = function getExpandedNodes() {
    return computedPropsRef.current.computedExpandedNodes;
  };

  var loadNodeAsync = (0, _react.useCallback)(function (data, callback) {
    return loadNodeAsync_FromProps(computedPropsRef, data, callback);
  }, []);

  var clearNodeChildrenCache = function clearNodeChildrenCache(nodeId) {
    var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var treeCache = arguments.length > 2 ? arguments[2] : undefined;
    var clearedMap = arguments.length > 3 ? arguments[3] : undefined;
    var computedProps = computedPropsRef.current;
    clearedMap = clearedMap || {};

    if (!computedProps) {
      return clearedMap;
    }

    var isRoot = !treeCache;
    treeCache = treeCache || _objectSpread({}, getNodeCache());
    var data = computedProps.dataMap[nodeId];

    if (!data) {
      return clearedMap;
    }

    var nodeCache = treeCache[nodeId];
    var childNodes = nodeCache != null ? nodeCache[computedProps.nodesProperty] : data[computedProps.nodesProperty];

    if (childNodes && recursive && computedProps.initialProps.collapseChildrenOnAsyncNodeCollapse) {
      var _computedProps$initia = computedProps.initialProps,
          generateIdFromPath = _computedProps$initia.generateIdFromPath,
          nodePathSeparator = _computedProps$initia.nodePathSeparator;
      childNodes.forEach(function (childNode) {
        if (!childNode) {
          return;
        }

        var childId = computedProps.getItemId(childNode);

        if (childNode.__nodeProps) {
          childId = childNode.__nodeProps.key;
        } else if (generateIdFromPath) {
          childId = "".concat(nodeId).concat(nodePathSeparator).concat(childId);
        }

        clearedMap[childId] = true;
        computedProps.clearNodeChildrenCache(childId, recursive, treeCache, clearedMap);
      });
    }

    treeCache[nodeId] = _objectSpread(_objectSpread({}, nodeCache), {}, (0, _defineProperty2.default)({}, computedProps.initialProps.nodesProperty, data.__nodeProps ? data.__nodeProps.initialNodes : data[computedProps.initialProps.nodesProperty]));

    if (isRoot) {
      setNodeCache(treeCache, {
        nodeId: nodeId,
        node: data
      });
      return clearedMap;
    }

    return clearedMap;
  };

  var setNodeExpandedById = function setNodeExpandedById(id, expanded) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (!computedProps.dataMap) {
      return;
    }

    var collapsingNodesRef = computedProps.collapsingNodesRef;
    var data = computedProps.dataMap[id];

    if (!data) {
      return;
    }

    if (data.__nodeProps && data.__nodeProps.leafNode) {
      return;
    }

    if (data.__nodeProps && data.__nodeProps.expanded === expanded && config.force !== true) {
      return;
    }

    var treeCache = computedProps.computedNodeCache;
    var clearedCacheIds;
    var __collapsingNodes = collapsingNodesRef.current;
    var queue = (0, _batchUpdate.default)();

    var doExpandOrCollapse = function doExpandOrCollapse() {
      var expandedNodes = _objectSpread({}, getExpandedNodes());

      if (!expanded) {
        var recursive = !!computedProps.loadNode;
        delete expandedNodes[id];

        if (__collapsingNodes && __collapsingNodes[id]) {
          delete __collapsingNodes[id];
        }

        if (recursive && clearedCacheIds && computedProps.collapseChildrenOnAsyncNodeCollapse) {
          for (var _id in clearedCacheIds) {
            delete expandedNodes[_id];
          }
        }

        if (computedProps.collapseChildrenRecursive) {
          for (var childId in expandedNodes) {
            if (childId.indexOf(id) === 0) {
              delete expandedNodes[childId];
            }
          }
        }
      } else {
        expandedNodes[id] = true;
      }

      setExpandedNodes(expandedNodes, undefined, {
        data: data,
        expanded: expanded,
        id: id
      });
    };

    if (!expanded) {
      collapsingNodesRef.current = __collapsingNodes || {};
      collapsingNodesRef.current[id] = true;
    }

    if (!expanded) {
      queue(function () {
        var nodeCache = treeCache ? treeCache[id] : undefined;

        if (nodeCache !== undefined && !computedProps.initialProps.loadNodeOnce) {
          var recursive = !!computedProps.initialProps.loadNode;
          clearedCacheIds = clearNodeChildrenCache(id, recursive, treeCache);
          doExpandOrCollapse();
        } else {
          doExpandOrCollapse();
        }
      });
      queue.commit();
      return;
    }

    queue(function () {
      if (expanded && data.__nodeProps && data.__nodeProps.asyncNode) {
        loadNodeAsync(data, doExpandOrCollapse);
      } else {
        doExpandOrCollapse();
      }
    });
    queue.commit();
  };

  var setNodeExpandedAt = function setNodeExpandedAt(index, expanded) {
    var data = computedProps.getItemAt(index);

    if (!data) {
      return;
    }

    var id = computedProps.getItemId(data);
    return setNodeExpandedById(id, expanded);
  };

  var toggleNodeExpand = (0, _react.useCallback)(function (dataOrIndex) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    var data = typeof dataOrIndex === 'number' ? computedProps.getItemAt(dataOrIndex) : dataOrIndex;

    if (!data) {
      return;
    }

    var id = computedProps.getItemId(data);
    var expanded = isNodeExpanded(data);

    if (typeof dataOrIndex === 'number') {
      computedProps.setActiveIndex(dataOrIndex);
    } else {
      var rowIndex = computedProps.getRowIndexById(id);
      computedProps.setActiveIndex(rowIndex);
    }

    return setNodeExpandedById(id, !expanded);
  }, []);
  var getNodeCache = (0, _react.useCallback)(function () {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return {};
    }

    return computedProps.computedNodeCache || {};
  }, []);

  var appendCacheForNode = function appendCacheForNode(nodeId, node) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    var nodeCache = _objectSpread({}, getNodeCache());

    if (node === undefined) {
      delete nodeCache[nodeId];
    } else {
      nodeCache[nodeId] = _objectSpread(_objectSpread({}, nodeCache[nodeId]), node);
    }

    computedProps.setNodeCache(nodeCache, {
      nodeId: nodeId,
      node: node
    });
  };

  var setNodeCache = function setNodeCache(nodeCache, info) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (computedProps.initialProps.onNodeCache) {
      computedProps.initialProps.onNodeCache(nodeCache, info);
    }

    doSetNodeCache(nodeCache);
  };

  var computedExpandedNodes = expandedNodes;
  var computedNodeCache = nodeCache;
  var computedLoadingNodes = loadingNodes;
  var once = !!computedProps.initialProps.loadNodeOnce;
  var computedLoadNode = once ? computedProps.initialProps.loadNodeOnce : computedProps.initialProps.loadNode;

  var computeAllNodes = function computeAllNodes(dataArray) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_OBJECT;
    var parentNode = arguments.length > 2 ? arguments[2] : undefined;
    var result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var idProperty = config.idProperty;
    var nodesName = config.nodesName;
    var pathSeparator = config.pathSeparator;
    var generateIdFromPath = computedProps.generateIdFromPath;
    dataArray.forEach(function (item) {
      if (item) {
        var itemId = item[idProperty];
        var itemNodes = item[nodesName];
        var parentNodeId = parentNode ? parentNode[idProperty] : undefined;
        var path = parentNode ? "".concat(parentNodeId).concat(pathSeparator).concat(itemId) : "".concat(itemId);

        if (generateIdFromPath) {
          item[idProperty] = path;
        }

        result[path] = true;

        if (Array.isArray(itemNodes)) {
          computeAllNodes(itemNodes, config, item, result);
        }
      }
    });
    return result;
  };

  var collapseAllTreeNodes = function collapseAllTreeNodes() {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    setExpandedNodes({});
  };

  var expandAllTreeNodes = function expandAllTreeNodes() {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    var config = {
      idProperty: !computedProps.compoundIdProperty ? computedProps.idProperty : 'id',
      nodesName: computedProps.nodesProperty || 'nodes',
      pathSeparator: computedProps.nodePathSeparator || '/',
      generateIdFromPath: computedProps.generateIdFromPath
    };
    var originalData = JSON.stringify(computedProps.originalData || []);
    var cloneOriginalData = (0, _toConsumableArray2.default)(JSON.parse(originalData));
    var allNodes = computeAllNodes(cloneOriginalData, config);
    setExpandedNodes(allNodes);
  };

  return {
    clearNodeChildrenCache: clearNodeChildrenCache,
    toggleNodeExpand: toggleNodeExpand,
    loadNodeAsync: loadNodeAsync,
    collapsingNodesRef: collapsingNodesRef,
    setLoadingNodes: setLoadingNodes,
    computedTreeEnabled: computedTreeEnabled,
    computedLoadNode: computedLoadNode,
    computedExpandedNodes: computedExpandedNodes,
    computedLoadingNodes: computedLoadingNodes,
    computedNodeCache: computedNodeCache,
    getNodeCache: getNodeCache,
    setNodeCache: setNodeCache,
    appendCacheForNode: appendCacheForNode,
    isNodeExpandableAt: isNodeExpandableAt,
    isNodeExpanded: isNodeExpanded,
    setNodeExpandedAt: setNodeExpandedAt,
    setNodeExpandedById: setNodeExpandedById,
    collapseAllTreeNodes: collapseAllTreeNodes,
    expandAllTreeNodes: expandAllTreeNodes
  };
};

var _default = useTreeColumn;
exports.default = _default;