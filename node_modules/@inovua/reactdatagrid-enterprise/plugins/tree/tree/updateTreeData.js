/**
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the Commercial License found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var updateTreeDataIds = function updateTreeDataIds(data, config) {
  var idProperty = config.idProperty;
  var nodesName = config.nodesName;

  var updateIds = function updateIds(dataArr) {
    for (var i = 0; i < dataArr.length; i++) {
      var item = dataArr[i];

      if (!item) {
        continue;
      }

      var itemNodes = item[nodesName];
      item[idProperty] = i + 1;

      if (Array.isArray(itemNodes)) {
        updateIds(itemNodes);
      }
    }
  };

  updateIds(data);
  return data;
};

var computeTreeData = function computeTreeData(dataArray, config) {
  var idProperty = config.idProperty;
  var nodesName = config.nodesName;
  var pathSeparator = config.pathSeparator;
  var expandedNodes = config.expandedNodes;
  var generateIdFromPath = config.generateIdFromPath;
  var selectedPath = config.selectedPath;
  var destinationPath = config.destinationPath;
  var value = [];
  var counter = 0;

  var computeData = function computeData(data, idSelected, destinationId) {
    var result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var parentNode = arguments.length > 4 ? arguments[4] : undefined;
    var initialIdSelected = '';

    for (var i = 0; i < data.length; i++) {
      if (initialIdSelected === '') {
        initialIdSelected = idSelected;
      }

      if (counter === 2) {
        break;
      }

      var item = data[i];

      if (!item) {
        continue;
      }

      var itemId = "".concat(item[idProperty]);
      var itemNodes = item[nodesName];
      var parentNodeId = parentNode ? "".concat(parentNode[idProperty]) : undefined;
      var path = parentNode ? "".concat(parentNodeId).concat(pathSeparator).concat(item[idProperty]) : "".concat(item[idProperty]);

      if (generateIdFromPath) {
        item[idProperty] = path;
      }

      if (parentNode === undefined) {
        result.push(item);
      } else {
        var parentNodes = parentNode[nodesName];

        if (path === initialIdSelected) {
          value.push(item);
          parentNodes.splice(i, 1);
          counter++;
        }

        if (path === destinationId) {
          var nodeId = item[idProperty].split(pathSeparator);
          var idInNodes = nodeId.splice(nodeId.length - 1, 1);
          var index = parseInt(idInNodes);
          parentNodes.splice(index, 0, value[0]);
          counter++;
        }
      }

      if (expandedNodes && expandedNodes[itemId]) {
        if (Array.isArray(itemNodes)) {
          computeData(itemNodes, idSelected, destinationId, result, item);
        }
      }
    }

    return result;
  };

  var computedData = computeData(dataArray, selectedPath, destinationPath);
  var updatedData = updateTreeDataIds(computedData, config);
  return updatedData;
};

var updateTreeData = function updateTreeData(props, _ref) {
  var selectedPath = _ref.selectedPath,
      destinationPath = _ref.destinationPath;
  var originalData = props.originalData || [];
  var config = {
    idProperty: props.idProperty,
    nodesName: props.nodesProperty,
    pathSeparator: props.nodePathSeparator,
    expandedNodes: props.computedExpandedNodes,
    generateIdFromPath: props.generateIdFromPath,
    selectedPath: selectedPath,
    destinationPath: destinationPath
  };
  computeTreeData(originalData, config);
};

var _default = updateTreeData;
exports.default = _default;