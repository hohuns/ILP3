/**
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the Commercial License found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sortTreeDataWithInfo = exports.sortTreeData = exports.expandByIdsWithInfo = exports.expandByIds = exports.expandAtIndexes = exports.expandAtIndex = exports.collapseByIds = exports.collapseAtIndexes = exports.collapseAtIndexWithInfo = exports.collapseAtIndex = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _sorty = _interopRequireDefault(require("@inovua/reactdatagrid-community/packages/sorty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var EMPTY_OBJECT = {};

var sortAsc = function sortAsc(a, b) {
  return a - b;
};

var identity = function identity(a) {
  return a;
};

var augmentNode = function augmentNode(n, parentNode, index) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EMPTY_OBJECT;
  var idProperty = config.idProperty || 'id';
  var pathSeparator = config.pathSeparator || '/';
  var nodesName = config.nodesName || 'nodes';
  var expandedNodes = config.expandedNodes || EMPTY_OBJECT;
  var dataSourceCache = config.dataSourceCache || EMPTY_OBJECT;
  var nodeCache = config.nodeCache || EMPTY_OBJECT;
  var loadingNodes = config.loadingNodes || EMPTY_OBJECT;

  if (!n) {
    return;
  }

  if (!n[idProperty]) {
    console.error("Set the correct \"idProperty\".");
    return;
  }

  var parentNodeId = parentNode ? parentNode[idProperty] : undefined;
  var path = parentNode ? "".concat(parentNodeId).concat(pathSeparator).concat(n[idProperty]) : "".concat(n[idProperty]);
  var cacheKey = config.generateIdFromPath ? path : n[idProperty];
  var initialNodes = n[nodesName];

  if (dataSourceCache[cacheKey]) {
    n = _objectSpread(_objectSpread({}, n), dataSourceCache[cacheKey]);
  }

  if (nodeCache[cacheKey]) {
    n = _objectSpread(_objectSpread({}, n), nodeCache[cacheKey]);
  }

  var itemNodes = n[nodesName];
  var extraNodeProps = n ? n.__extraNodeProps : undefined;
  var existingDepth = extraNodeProps ? extraNodeProps.depth : undefined;
  var depth = existingDepth !== undefined ? existingDepth : parentNode ? parentNode.__nodeProps ? parentNode.__nodeProps.depth + 1 : 1 : 0;
  var nodeProps = (config.nodeProps || identity)({
    leafNode: itemNodes === undefined,
    asyncNode: itemNodes === null,
    expanded: !!expandedNodes[cacheKey],
    loading: !!loadingNodes[cacheKey],
    initialNodes: initialNodes,
    parentNodeId: parentNodeId,
    path: path,
    key: cacheKey,
    childIndex: index,
    itemNodesCount: Array.isArray(itemNodes) ? itemNodes.length : 0,
    depth: depth
  }, n);

  if (config.isNodeLeaf) {
    nodeProps.leafNode = config.isNodeLeaf({
      node: n,
      nodeProps: nodeProps
    });
  }

  if (config.isNodeAsync) {
    nodeProps.asyncNode = config.isNodeAsync({
      node: n,
      nodeProps: nodeProps
    });
  }

  var result = _objectSpread(_objectSpread({}, n), {}, {
    __nodeProps: nodeProps
  });

  if (config.generateIdFromPath) {
    result[idProperty] = path;
  }

  return result;
};

var expandAtIndexWithInfo = function expandAtIndexWithInfo(dataArray, index) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;
  var nodesName = config.nodesName || 'nodes';
  var idProperty = config.idProperty || 'id';
  var node = dataArray[index];

  if (!node) {
    return {
      data: dataArray,
      insertCount: 0
    };
  }

  var nextNode = dataArray[index + 1];
  var parentNodeId = node[idProperty];
  var nodes = node[nodesName];

  if (!Array.isArray(nodes) || !nodes.length || nextNode && nextNode.__nodeProps && nextNode.__nodeProps.parentNodeId === parentNodeId) {
    return {
      data: dataArray,
      insertCount: 0
    };
  }

  var insertIds = {};
  nodes = nodes.map(function (n, index) {
    return augmentNode(n, node, index, config);
  });
  return {
    data: dataArray.slice(0, index).concat(node).concat(nodes).concat(dataArray.slice(index + 1)),
    insertNodes: nodes,
    insertIds: insertIds,
    insertCount: nodes.length
  };
};

var expandAtIndexes = function expandAtIndexes(dataArray, indexes) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;
  indexes = indexes.sort(sortAsc);
  var alreadyInserted = 0;

  if (!Array.isArray(indexes) || !indexes.length) {
    return dataArray;
  }

  return indexes.reduce(function (dataSource, index) {
    var _expandAtIndexWithInf = expandAtIndexWithInfo(dataSource, index + alreadyInserted, config),
        data = _expandAtIndexWithInf.data,
        insertCount = _expandAtIndexWithInf.insertCount;

    alreadyInserted += insertCount;
    return data;
  }, dataArray);
};

exports.expandAtIndexes = expandAtIndexes;

var collapseAtIndexes = function collapseAtIndexes(dataArray, indexes) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;
  indexes = indexes.sort(sortAsc);
  var alreadyRemoved = 0;

  if (!Array.isArray(indexes) || !indexes.length) {
    return dataArray;
  }

  return indexes.reduce(function (dataSource, index) {
    var _collapseAtIndexWithI = collapseAtIndexWithInfo(dataSource, index - alreadyRemoved, config),
        data = _collapseAtIndexWithI.data,
        removeCount = _collapseAtIndexWithI.removeCount;

    alreadyRemoved += removeCount;
    return data;
  }, dataArray);
};

exports.collapseAtIndexes = collapseAtIndexes;

var expandAtIndex = function expandAtIndex(dataArray, index) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;

  var _expandAtIndexWithInf2 = expandAtIndexWithInfo(dataArray, index, config),
      data = _expandAtIndexWithInf2.data;

  return data;
};

exports.expandAtIndex = expandAtIndex;

var expandByIds = function expandByIds(dataArray, idMap) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;

  var _expandByIdsWithInfo = expandByIdsWithInfo(dataArray, idMap, config),
      data = _expandByIdsWithInfo.data;

  return data;
};

exports.expandByIds = expandByIds;

var expandByIdsWithInfo = function expandByIdsWithInfo(dataArray) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_OBJECT;
  var parentNode = arguments.length > 2 ? arguments[2] : undefined;
  var result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var idToIndexMap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var dataMap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  var startIndex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var nodesToExpand = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];
  var idProperty = config.idProperty || 'id';
  var nodesName = config.nodesName || 'nodes';
  var expandedNodes = config.expandedNodes || EMPTY_OBJECT;
  var nextItem;
  var itemAlreadyExpanded;
  var itemId;
  var itemNodes;
  dataArray.forEach(function (item, i) {
    item = augmentNode(item, parentNode, i, config);

    if (item) {
      itemId = item[idProperty];
      itemNodes = item[nodesName];
      idToIndexMap[itemId] = i + startIndex;
      dataMap[itemId] = item;
      result.push(item);

      if (expandedNodes[itemId]) {
        if (Array.isArray(itemNodes)) {
          nextItem = dataArray[i + 1];
          itemAlreadyExpanded = nextItem && nextItem.__nodeProps && nextItem.__nodeProps.parentNodeId === itemId;

          if (!itemAlreadyExpanded) {
            var startFrom = result.length;
            expandByIdsWithInfo(itemNodes, config, item, result, idToIndexMap, dataMap, startFrom, nodesToExpand);
            startIndex += result.length - startFrom;
          }
        } else if (item.__nodeProps.expanded && !item.__nodeProps.loading && item.__nodeProps.asyncNode && !item.__nodeProps.itemNodesCount && (!config.collapsingNodes || !config.collapsingNodes[itemId])) {
          nodesToExpand.push(item);
        }
      }
    }
  });
  return {
    data: result,
    dataMap: dataMap,
    idToIndexMap: idToIndexMap,
    nodesToExpand: nodesToExpand
  };
};

exports.expandByIdsWithInfo = expandByIdsWithInfo;

var collapseByIds = function collapseByIds(dataArray, idMap) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;
  var idToIndexMap = config.idToIndexMap;

  if (!idToIndexMap) {
    throw new Error("The last argument to \"collapseByIds\" should contain a \"idToIndexMap\" property. No such property found!");
  }

  var indexes = [];
  var index;

  for (var id in idMap) {
    index = idToIndexMap[id];

    if (index !== undefined) {
      indexes.push(index);
    }
  }

  return collapseAtIndexes(dataArray, indexes, config);
};

exports.collapseByIds = collapseByIds;

var collapseAtIndexWithInfo = function collapseAtIndexWithInfo(dataArray, index) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;
  var node = dataArray[index];
  var idProperty = config.idProperty || 'id';

  if (!node) {
    return {
      data: dataArray,
      removeCount: 0
    };
  }

  var parentNodeId = node[idProperty];
  var nodesName = config.nodesName || 'nodes';
  var nodes = node[nodesName];
  var nextNode = dataArray[index + 1];

  if (!Array.isArray(nodes) || !nodes.length || nextNode && (!nextNode.__nodeProps || nextNode.__nodeProps.parentNodeId !== parentNodeId)) {
    return {
      data: dataArray,
      removeCount: 0
    };
  }

  return {
    data: dataArray.slice(0, index).concat(node).concat(dataArray.slice(index + nodes.length + 1)),
    removeCount: nodes.length
  };
};

exports.collapseAtIndexWithInfo = collapseAtIndexWithInfo;

var collapseAtIndex = function collapseAtIndex(dataArray, index) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;

  var _collapseAtIndexWithI2 = collapseAtIndexWithInfo(dataArray, index, config),
      data = _collapseAtIndexWithI2.data;

  return data;
};

exports.collapseAtIndex = collapseAtIndex;

var sortTreeData = function sortTreeData(sortInfo, dataArray) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? 0 : _ref$depth,
      deep = _ref.deep;

  var _sortTreeDataWithInfo = sortTreeDataWithInfo(sortInfo, dataArray, depth),
      data = _sortTreeDataWithInfo.data,
      maxDepth = _sortTreeDataWithInfo.maxDepth;

  if (deep) {
    var currentDepth = depth;

    while (currentDepth < maxDepth) {
      currentDepth++;
      data = sortTreeDataWithInfo(sortInfo, data, currentDepth).data;
    }
  }

  return data;
};

exports.sortTreeData = sortTreeData;

var sortTreeDataWithInfo = function sortTreeDataWithInfo(sortInfo, dataArray) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var item;
  var index = 0;
  var currentDepth;
  var currentPath;
  var prevItemDepth = -1;

  var _prevPath;

  var prevMatchingDepthPath;
  var arrayToSort;
  var currentNodeChildren = [];
  var map = {};
  var sortIndexStart;
  var maxDepth = 0;

  while (item = dataArray[index]) {
    currentDepth = item.__nodeProps.depth;
    currentPath = item.__nodeProps.path;
    maxDepth = Math.max(maxDepth, currentDepth);

    if (currentDepth === depth) {
      if (currentDepth > prevItemDepth) {
        arrayToSort = [];
        sortIndexStart = index;
      }

      arrayToSort.push(item);
    }

    if (prevItemDepth >= depth && currentDepth <= depth) {
      if (currentNodeChildren.length) {
        map[prevMatchingDepthPath] = currentNodeChildren;
        currentNodeChildren = [];
      }
    }

    if (currentDepth > depth) {
      currentNodeChildren.push(item);
    }

    if (currentDepth < depth && arrayToSort && arrayToSort.length) {
      (0, _sorty.default)(sortInfo, arrayToSort);

      for (var i = 0, sortItemChildren, sortItemPath, sortItem;; i < arrayToSort.length) {
        sortItem = arrayToSort[i];

        if (!sortItem) {
          break;
        }

        sortItemPath = sortItem.__nodeProps.path;
        sortItemChildren = map[sortItemPath];

        if (Array.isArray(sortItemChildren)) {
          var _arrayToSort;

          (_arrayToSort = arrayToSort).splice.apply(_arrayToSort, [i + 1, 0].concat((0, _toConsumableArray2.default)(sortItemChildren)));

          i += sortItemChildren.length;
        }

        i++;
      }

      dataArray.splice.apply(dataArray, [sortIndexStart, arrayToSort.length].concat((0, _toConsumableArray2.default)(arrayToSort)));
      arrayToSort = [];
    }

    index++;

    if (currentDepth === depth) {
      prevMatchingDepthPath = currentPath;
    }

    prevItemDepth = currentDepth;
    _prevPath = currentPath;
  }

  if (currentNodeChildren.length) {
    map[prevMatchingDepthPath] = currentNodeChildren;
  }

  if (arrayToSort && arrayToSort.length) {
    (0, _sorty.default)(sortInfo, arrayToSort);
    var idx = 0;

    var _sortItemChildren;

    var _sortItemPath;

    var _sortItem;

    for (;; idx < arrayToSort.length) {
      _sortItem = arrayToSort[idx];

      if (!_sortItem) {
        break;
      }

      _sortItemPath = _sortItem.__nodeProps.path;
      _sortItemChildren = map[_sortItemPath];

      if (Array.isArray(_sortItemChildren)) {
        var _arrayToSort2;

        (_arrayToSort2 = arrayToSort).splice.apply(_arrayToSort2, [idx + 1, 0].concat((0, _toConsumableArray2.default)(_sortItemChildren)));

        idx += _sortItemChildren.length;
      }

      idx++;
    }

    dataArray.splice.apply(dataArray, [sortIndexStart, arrayToSort.length].concat((0, _toConsumableArray2.default)(arrayToSort)));
  }

  return {
    data: dataArray,
    maxDepth: maxDepth
  };
};

exports.sortTreeDataWithInfo = sortTreeDataWithInfo;